#!/bin/bash
# GitHub CLI extension to create issues in chat-template repo and add them to the Chat Template Project
# Usage: gh issue-create [feature|bug|task] --title "Title" [--body "Body"] [--assignee USER] [--label LABEL]

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/../.." && pwd)"
UTILS_DIR="$PROJECT_ROOT/scripts/utils"

# Source utility functions (check if they exist)
# Note: github_repo.sh sources common.sh with a relative path, so we need to cd to utils first
if [[ -f "$UTILS_DIR/common.sh" ]]; then
    source "$UTILS_DIR/common.sh"
fi
if [[ -f "$UTILS_DIR/config_parser.sh" ]]; then
    source "$UTILS_DIR/config_parser.sh"
fi
if [[ -f "$UTILS_DIR/github_repo.sh" ]]; then
    source "$UTILS_DIR/github_repo.sh"
fi

# Default values
ISSUE_TYPE=""
TITLE=""
BODY=""
ASSIGNEE=""
LABELS=""
PROJECT_NAME="Chat Template Project"
REPO=""
PROJECT_FIELDS=()  # Repeated --field "Name=Value"
PROJECT_TYPE_OVERRIDE=""

# Colors for output
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
NC='\033[0m' # No Color

show_usage() {
    cat << EOF
${GREEN}GitHub Issue Creator${NC}
Creates a GitHub issue in the chat-template repo and adds it to the "Chat Template Project".

Usage:
  gh issue-create <type> [options]

Issue Types:
  feature    Create a feature request issue
  bug        Create a bug report issue
  task       Create a task issue

Options:
  --title TITLE          Issue title (required)
  --body BODY            Issue body/description
  --assignee USER        Assign issue to a user
  --label LABEL          Add additional labels (can be used multiple times)
  --field NAME=VALUE     Set a project field value (can be used multiple times)
  --type TYPE            Override project Type field (e.g. Initiative, Epic, Task, Bug, Feature)
  --repo OWNER/REPO      Override repository (default: from infra.yaml or git remote)
  --project NAME         Override project name (default: "Chat Template Project")
  --help, -h             Show this help message

Examples:
  gh issue-create feature --title "Add dark mode support"
  gh issue-create bug --title "Login button not working" --body "The login button does nothing when clicked"
  gh issue-create task --title "Update documentation" --assignee @me
  gh issue-create task --title "Release pipeline update" --field "Priority=P0" --field "Start Date=2/17/26"
  gh issue-create task --title "POC Release" --type "Initiative"
  gh issue-create task --title "Implement deploy flow" --field "Parent issue=#20"

Note: This command requires GitHub CLI authentication with project scope.
      Run: gh auth refresh -s project
EOF
}

# Parse command line arguments
parse_args() {
    if [[ $# -eq 0 ]]; then
        show_usage
        exit 1
    fi

    # First argument should be the issue type
    case "$1" in
        feature|bug|task)
            ISSUE_TYPE="$1"
            shift
            ;;
        --help|-h)
            show_usage
            exit 0
            ;;
        *)
            echo -e "${RED}Error: Invalid issue type '$1'${NC}"
            echo "Valid types: feature, bug, task"
            show_usage
            exit 1
            ;;
    esac

    # Parse remaining options
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --title)
                TITLE="$2"
                shift 2
                ;;
            --body)
                BODY="$2"
                shift 2
                ;;
            --assignee)
                ASSIGNEE="$2"
                shift 2
                ;;
            --label)
                if [[ -z "$LABELS" ]]; then
                    LABELS="$2"
                else
                    LABELS="$LABELS,$2"
                fi
                shift 2
                ;;
            --field)
                PROJECT_FIELDS+=("$2")
                shift 2
                ;;
            --type)
                PROJECT_TYPE_OVERRIDE="$2"
                shift 2
                ;;
            --repo)
                REPO="$2"
                shift 2
                ;;
            --project)
                PROJECT_NAME="$2"
                shift 2
                ;;
            --help|-h)
                show_usage
                exit 0
                ;;
            *)
                echo -e "${RED}Error: Unknown option '$1'${NC}"
                show_usage
                exit 1
                ;;
        esac
    done

    # Validate required arguments
    if [[ -z "$TITLE" ]]; then
        echo -e "${RED}Error: --title is required${NC}"
        show_usage
        exit 1
    fi
}

# Get the template file path based on issue type
get_template_path() {
    local type="$1"
    case "$type" in
        feature)
            echo "$PROJECT_ROOT/.github/ISSUE_TEMPLATE/feature_request.md"
            ;;
        bug)
            echo "$PROJECT_ROOT/.github/ISSUE_TEMPLATE/bug_report.md"
            ;;
        task)
            echo "$PROJECT_ROOT/.github/ISSUE_TEMPLATE/task.md"
            ;;
        *)
            echo ""
            ;;
    esac
}

# Extract the default label from the template
get_default_label() {
    local template_path="$1"
    if [[ -f "$template_path" ]]; then
        # Extract label from frontmatter
        grep -E "^labels:" "$template_path" | head -1 | sed -E 's/^labels:[[:space:]]*(.+)$/\1/' | tr -d ' "'
    fi
}

# Extract the title prefix from the template
get_title_prefix() {
    local template_path="$1"
    if [[ -f "$template_path" ]]; then
        # Extract title prefix from frontmatter (e.g., "title: '[FEATURE] '" -> "FEATURE")
        # The template format is: title: '[FEATURE] ' or title: '[BUG] ' etc.
        # Extract content between the first [ and first ]
        grep -E "^title:" "$template_path" | head -1 | sed 's/.*\[\([^]]*\)\].*/\1/'
    fi
}

# Turn free-form text into up to N bullet items.
# If no meaningful bullets can be derived, outputs "- N/A".
to_bullets() {
    local text="$1"
    local max_items="${2:-3}"
    local emitted=0

    if [[ -z "${text// }" ]]; then
        echo "- N/A"
        return
    fi

    # Split on newlines first, then sentence boundaries.
    while IFS= read -r line; do
        local trimmed
        trimmed=$(echo "$line" | sed -E 's/^[[:space:]]+|[[:space:]]+$//g')
        [[ -z "$trimmed" ]] && continue

        # Split this line into sentence-like chunks.
        while IFS= read -r chunk; do
            local c
            c=$(echo "$chunk" | sed -E 's/^[[:space:][:punct:]]+|[[:space:][:punct:]]+$//g')
            [[ -z "$c" ]] && continue
            echo "- $c"
            emitted=$((emitted + 1))
            [[ "$emitted" -ge "$max_items" ]] && return
        done < <(echo "$trimmed" | sed -E 's/[.;][[:space:]]+/\n/g')
    done < <(printf "%s\n" "$text")

    if [[ "$emitted" -eq 0 ]]; then
        echo "- N/A"
    fi
}

# Build issue body with all template sections filled.
# Use concrete content where possible; use N/A only when a section truly has no content.
build_issue_body() {
    local template_path="$1"
    local provided_body="$2"

    local summary="${provided_body:-N/A}"
    local title_text="${TITLE:-N/A}"
    local objective_bullets
    objective_bullets=$(to_bullets "$provided_body" 3)

    case "$ISSUE_TYPE" in
        task)
            cat <<EOF
## Task Description
$summary

## Objective
$objective_bullets

## Requirements
- [ ] Implement the requested change: $title_text
- [ ] Validate the updated behavior in the relevant workflow/environment

## Deliverables
- Updated implementation for: $title_text
- Evidence of validation (logs/tests/notes), or N/A if not applicable

## Acceptance Criteria
- [ ] The requested outcome is implemented
- [ ] The change can be verified and tracked in the project board

## Dependencies
N/A

## Additional Context
$summary

## Notes
N/A
EOF
            ;;
        feature)
            cat <<EOF
## Feature Description
$summary

## Problem Statement
$summary

## Proposed Solution
$(to_bullets "$provided_body" 4)

## Impact (Optional)
- Primary benefit: improved workflow consistency and reduced manual overhead
- Additional impact: N/A

## Additional Context (Optional)
$summary

## Implementation Notes (Optional)
- Follow existing repository CI/CD and release workflow conventions

## Alternatives Considered (Optional)
N/A
EOF
            ;;
        bug)
            cat <<EOF
## Bug Description
$summary

## Steps to Reproduce
1. Execute the workflow/process related to: $title_text
2. Observe the current behavior/output
3. Compare against expected behavior

## Expected Behavior
The process should behave as intended for: $title_text

## Actual Behavior
$summary

## Environment
- OS: N/A
- Python Version: N/A
- Environment: N/A
- Version/Commit: N/A
- Browser: N/A

## Error Messages/Logs
\`\`\`
N/A
\`\`\`

## Screenshots
N/A

## Additional Context
$summary

## Possible Solution
$(to_bullets "$provided_body" 3)
EOF
            ;;
        *)
            # Fallback for unknown type: preserve useful information.
            if [[ -f "$template_path" ]]; then
                awk '
                    /^---$/ {
                        if (frontmatter_count == 0) {
                            frontmatter_count = 1
                            next
                        } else if (frontmatter_count == 1) {
                            frontmatter_count = 2
                            next
                        }
                    }
                    frontmatter_count == 2 {
                        print
                    }
                ' "$template_path"
            else
                echo "$summary"
            fi
            ;;
    esac
}

# Resolve repository name
resolve_repo() {
    if [[ -n "$REPO" ]]; then
        echo "$REPO"
        return 0
    fi
    
    # Try to get from infra.yaml or git remote
    local repo=""
    if command -v resolve_github_repo &> /dev/null; then
        if repo=$(resolve_github_repo 2>/dev/null); then
            echo "$repo"
            return 0
        fi
    fi
    
    # Fallback: try to get from git remote directly
    if command -v git &> /dev/null && git rev-parse --git-dir &> /dev/null; then
        local remote_url
        remote_url=$(git remote get-url origin 2>/dev/null || echo "")
        if [[ -n "$remote_url" ]]; then
            repo=$(echo "$remote_url" | sed -E 's|.*github\.com[:/]([^/]+/[^/]+)(\.git)?$|\1|' | sed 's|\.git$||')
            if [[ -n "$repo" ]]; then
                echo "$repo"
                return 0
            fi
        fi
    fi
    
    return 1
}

# Find project ID by name (supports both classic projects and project v2)
find_project_id() {
    local repo="$1"
    local project_name="$2"
    local org="${repo%%/*}"
    
    is_valid_classic_id() {
        [[ "$1" =~ ^[0-9]+$ ]]
    }
    is_valid_v2_id() {
        [[ "$1" =~ ^PVT_ ]]
    }
    
    # Try repository-level projects (classic)
    local project_id
    project_id=$(gh api "repos/${repo}/projects" --jq ".[] | select(.name == \"${project_name}\") | .id" 2>/dev/null || echo "")
    
    if [[ -n "$project_id" ]] && is_valid_classic_id "$project_id"; then
        echo "$project_id"
        return 0
    fi
    
    # Try organization-level projects (classic)
    project_id=$(gh api "orgs/${org}/projects" --jq ".[] | select(.name == \"${project_name}\") | .id" 2>/dev/null || echo "")
    
    if [[ -n "$project_id" ]] && is_valid_classic_id "$project_id"; then
        echo "$project_id"
        return 0
    fi
    
    # Try project v2 (GraphQL API)
    project_id=$(gh api graphql \
        -f query='
        query($org: String!, $projectName: String!) {
            organization(login: $org) {
                projectsV2(first: 20, query: $projectName) {
                    nodes {
                        id
                        title
                    }
                }
            }
        }' \
        -f org="$org" \
        -f projectName="$project_name" \
        --jq ".data.organization.projectsV2.nodes[] | select(.title == \"${project_name}\") | .id" 2>/dev/null || echo "")
    
    if [[ -n "$project_id" ]] && is_valid_v2_id "$project_id"; then
        echo "$project_id"
        return 0
    fi
    
    # Try user-level projects v2 (in case it's a user repo)
    project_id=$(gh api graphql \
        -f query='
        query($owner: String!, $projectName: String!) {
            user(login: $owner) {
                projectsV2(first: 20, query: $projectName) {
                    nodes {
                        id
                        title
                    }
                }
            }
        }' \
        -f owner="$org" \
        -f projectName="$project_name" \
        --jq ".data.user.projectsV2.nodes[] | select(.title == \"${project_name}\") | .id" 2>/dev/null || echo "")
    
    if [[ -n "$project_id" ]] && is_valid_v2_id "$project_id"; then
        echo "$project_id"
        return 0
    fi
    
    return 1
}

# Map issue type input to project Type field value
map_issue_type_to_project_type() {
    local issue_type="$1"
    case "$issue_type" in
        initiative|Initiative|INITIATIVE|innitiative|Innitiative|INNITIATIVE) echo "Initiative" ;;
        epic|Epic|EPIC) echo "Epic" ;;
        feature|Feature|FEATURE) echo "Feature" ;;
        bug|Bug|BUG) echo "Bug" ;;
        task|Task|TASK) echo "Task" ;;
        *) echo "" ;;
    esac
}

extract_title_type_token() {
    local title="$1"
    if [[ "$title" =~ ^\[([^]]+)\] ]]; then
        echo "${BASH_REMATCH[1]}"
    fi
}

infer_project_type_value() {
    local explicit_type="$1"
    local issue_type="$2"
    local full_title="$3"
    local template_label="$4"

    # 0) Explicit type override
    local mapped_explicit
    mapped_explicit=$(map_issue_type_to_project_type "$explicit_type")
    if [[ -n "$mapped_explicit" ]]; then
        echo "$mapped_explicit"
        return 0
    fi

    # 1) Prefer explicit [TYPE] prefix in title
    local title_token
    title_token=$(extract_title_type_token "$full_title")
    local mapped_from_title
    mapped_from_title=$(map_issue_type_to_project_type "$title_token")
    if [[ -n "$mapped_from_title" ]]; then
        echo "$mapped_from_title"
        return 0
    fi

    # 2) Next, try template label (Task/Bug/Feature)
    local mapped_from_label
    mapped_from_label=$(map_issue_type_to_project_type "$template_label")
    if [[ -n "$mapped_from_label" ]]; then
        echo "$mapped_from_label"
        return 0
    fi

    # 3) Fallback to categorized issue type
    map_issue_type_to_project_type "$issue_type"
}

# Set the Projects v2 "Type" single-select field on an item.
# Best effort: returns 0 if set, 1 if unavailable/failed.
set_project_v2_type_field() {
    local project_id="$1"
    local item_id="$2"
    local requested_type="$3"

    local type_name
    # Accept either normalized type values ("Task", "Epic", ...)
    # or shorthand tokens ("task", "epic", ...).
    type_name=$(map_issue_type_to_project_type "$requested_type")
    if [[ -z "$type_name" ]]; then
        type_name="$requested_type"
    fi
    if [[ -z "$type_name" ]]; then
        return 1
    fi

    # Find field id for the project's "Type" single-select field
    local type_field_id
    type_field_id=$(gh api graphql \
        -f query='
        query($projectId: ID!) {
            node(id: $projectId) {
                ... on ProjectV2 {
                    fields(first: 100) {
                        nodes {
                            ... on ProjectV2SingleSelectField {
                                id
                                name
                            }
                        }
                    }
                }
            }
        }' \
        -f projectId="$project_id" \
        --jq '.data.node.fields.nodes[] | select(.name == "Type") | .id' 2>/dev/null || echo "")

    [[ -z "$type_field_id" ]] && return 1

    # Find option id for desired Type value.
    # Query options through project fields directly (more reliable than node(fieldId)).
    local type_option_id
    type_option_id=$(gh api graphql \
        -f query='
        query($projectId: ID!) {
            node(id: $projectId) {
                ... on ProjectV2 {
                    fields(first: 100) {
                        nodes {
                            ... on ProjectV2SingleSelectField {
                                name
                                options {
                                    id
                                    name
                                }
                            }
                        }
                    }
                }
            }
        }' \
        -f projectId="$project_id" \
        --jq ".data.node.fields.nodes[] | select(.name == \"Type\") | .options[] | select(.name == \"${type_name}\") | .id" 2>/dev/null || echo "")

    [[ -z "$type_option_id" ]] && return 1

    # Set the field value
    gh api graphql \
        -f query='
        mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $optionId: String!) {
            updateProjectV2ItemFieldValue(
                input: {
                    projectId: $projectId
                    itemId: $itemId
                    fieldId: $fieldId
                    value: { singleSelectOptionId: $optionId }
                }
            ) {
                projectV2Item {
                    id
                }
            }
        }' \
        -f projectId="$project_id" \
        -f itemId="$item_id" \
        -f fieldId="$type_field_id" \
        -f optionId="$type_option_id" \
        --jq '.data.updateProjectV2ItemFieldValue.projectV2Item.id' >/dev/null 2>&1
}

# Normalize user date input to YYYY-MM-DD.
# Supports: YYYY-MM-DD, M/D/YY, M/D/YYYY, MM/DD/YY, MM/DD/YYYY
normalize_date_to_iso() {
    local raw_date="$1"
    python3 - "$raw_date" <<'PY'
import sys
from datetime import datetime

s = (sys.argv[1] or "").strip()
if not s:
    sys.exit(1)

formats = [
    "%Y-%m-%d",
    "%m/%d/%Y",
    "%m/%d/%y",
]

for fmt in formats:
    try:
        dt = datetime.strptime(s, fmt)
        print(dt.strftime("%Y-%m-%d"))
        sys.exit(0)
    except ValueError:
        pass

sys.exit(1)
PY
}

parse_parent_issue_number() {
    local repo="$1"
    local raw_value="$2"
    local value
    value="$(echo "$raw_value" | sed -E 's/^[[:space:]]+|[[:space:]]+$//g')"

    # #123
    if [[ "$value" =~ ^#([0-9]+)$ ]]; then
        echo "${BASH_REMATCH[1]}"
        return 0
    fi

    # 123
    if [[ "$value" =~ ^[0-9]+$ ]]; then
        echo "$value"
        return 0
    fi

    # https://github.com/owner/repo/issues/123
    if [[ "$value" =~ /issues/([0-9]+)$ ]]; then
        echo "${BASH_REMATCH[1]}"
        return 0
    fi

    # Title-based match (state: all), with robust fallback matching:
    # 1) exact title match (case-insensitive)
    # 2) exact match after removing [TYPE] prefix (case-insensitive)
    # 3) substring match after removing [TYPE] prefix (case-insensitive)
    local by_title
    by_title=$(gh issue list --repo "$repo" --state all --limit 200 --search "in:title \"$value\"" \
        --json number,title --jq '.[] | "\(.number)\t\(.title)"' 2>/dev/null \
        | awk -F'\t' -v q="$value" '
            BEGIN {
                IGNORECASE=1
                q_trim=q
                gsub(/^[[:space:]]+|[[:space:]]+$/, "", q_trim)
                q_lower=tolower(q_trim)
            }
            function strip_prefix(s) {
                gsub(/^[[:space:]]+|[[:space:]]+$/, "", s)
                sub(/^\[[^]]+\][[:space:]]*/, "", s)
                gsub(/^[[:space:]]+|[[:space:]]+$/, "", s)
                return s
            }
            {
                num=$1
                title=$2
                if (tolower(title) == q_lower) {
                    print num
                    exit
                }
            }
        ' | head -n1)
    if [[ -n "$by_title" ]]; then
        echo "$by_title"
        return 0
    fi

    by_title=$(gh issue list --repo "$repo" --state all --limit 200 --search "in:title \"$value\"" \
        --json number,title --jq '.[] | "\(.number)\t\(.title)"' 2>/dev/null \
        | awk -F'\t' -v q="$value" '
            BEGIN {
                IGNORECASE=1
                q_trim=q
                gsub(/^[[:space:]]+|[[:space:]]+$/, "", q_trim)
                q_lower=tolower(q_trim)
            }
            function strip_prefix(s) {
                gsub(/^[[:space:]]+|[[:space:]]+$/, "", s)
                sub(/^\[[^]]+\][[:space:]]*/, "", s)
                gsub(/^[[:space:]]+|[[:space:]]+$/, "", s)
                return s
            }
            {
                num=$1
                title=strip_prefix($2)
                if (tolower(title) == q_lower) {
                    print num
                    exit
                }
            }
        ' | head -n1)
    if [[ -n "$by_title" ]]; then
        echo "$by_title"
        return 0
    fi

    by_title=$(gh issue list --repo "$repo" --state all --limit 200 --search "in:title \"$value\"" \
        --json number,title --jq '.[] | "\(.number)\t\(.title)"' 2>/dev/null \
        | awk -F'\t' -v q="$value" '
            BEGIN {
                IGNORECASE=1
                q_trim=q
                gsub(/^[[:space:]]+|[[:space:]]+$/, "", q_trim)
                q_lower=tolower(q_trim)
            }
            function strip_prefix(s) {
                gsub(/^[[:space:]]+|[[:space:]]+$/, "", s)
                sub(/^\[[^]]+\][[:space:]]*/, "", s)
                gsub(/^[[:space:]]+|[[:space:]]+$/, "", s)
                return s
            }
            {
                num=$1
                title=tolower(strip_prefix($2))
                if (index(title, q_lower) > 0) {
                    print num
                    exit
                }
            }
        ' | head -n1)
    if [[ -n "$by_title" ]]; then
        echo "$by_title"
        return 0
    fi

    return 1
}

set_parent_issue_relationship() {
    local repo="$1"
    local child_issue_number="$2"
    local parent_raw_value="$3"

    local parent_issue_number
    parent_issue_number=$(parse_parent_issue_number "$repo" "$parent_raw_value" 2>/dev/null || true)
    [[ -z "$parent_issue_number" ]] && return 1
    [[ "$parent_issue_number" == "$child_issue_number" ]] && return 1

    # REST endpoint expects child issue "id" (numeric DB id), not issue number.
    local child_issue_id
    child_issue_id=$(gh api "repos/${repo}/issues/${child_issue_number}" --jq '.id' 2>/dev/null || true)
    [[ -z "$child_issue_id" ]] && return 1

    gh api -X POST "repos/${repo}/issues/${parent_issue_number}/sub_issues" \
        -F sub_issue_id="$child_issue_id" >/dev/null 2>&1
}

# Set a single arbitrary Projects v2 field by name.
# Supports:
# - Single select fields (Status/Priority/Size/Type)
# - Date fields (Start Date/Target Complete Date)
# - Number fields (Estimate)
# - Text fields (if present)
# - Iteration fields (by iteration title)
set_project_v2_field_value() {
    local project_id="$1"
    local item_id="$2"
    local field_name="$3"
    local raw_value="$4"

    # 1) Single-select path (if option exists for this field/value)
    local option_id
    option_id=$(gh api graphql \
        -f query='
        query($projectId: ID!) {
            node(id: $projectId) {
                ... on ProjectV2 {
                    fields(first: 100) {
                        nodes {
                            ... on ProjectV2SingleSelectField {
                                id
                                name
                                options {
                                    id
                                    name
                                }
                            }
                        }
                    }
                }
            }
        }' \
        -f projectId="$project_id" \
        --jq ".data.node.fields.nodes[] | select(.name == \"${field_name}\") | .options[] | select(.name == \"${raw_value}\") | .id" 2>/dev/null | head -n1)

    if [[ -n "$option_id" ]]; then
        # Resolve field id and set selected option.
        local field_id_for_option
        field_id_for_option=$(gh api graphql \
            -f query='
            query($projectId: ID!) {
                node(id: $projectId) {
                    ... on ProjectV2 {
                        fields(first: 100) {
                            nodes {
                                ... on ProjectV2SingleSelectField { id name }
                            }
                        }
                    }
                }
            }' \
            -f projectId="$project_id" \
            --jq ".data.node.fields.nodes[] | select(.name == \"${field_name}\") | .id" 2>/dev/null | head -n1)

        [[ -z "$field_id_for_option" ]] && return 1

        gh api graphql \
            -f query='
            mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $optionId: String!) {
                updateProjectV2ItemFieldValue(
                    input: {
                        projectId: $projectId
                        itemId: $itemId
                        fieldId: $fieldId
                        value: { singleSelectOptionId: $optionId }
                    }
                ) {
                    projectV2Item { id }
                }
            }' \
            -f projectId="$project_id" \
            -f itemId="$item_id" \
            -f fieldId="$field_id_for_option" \
            -f optionId="$option_id" \
            --jq '.data.updateProjectV2ItemFieldValue.projectV2Item.id' >/dev/null 2>&1
        return $?
    fi

    # 2) Standard field path (ProjectV2Field with dataType)
    local field_id
    field_id=$(gh api graphql \
        -f query='
        query($projectId: ID!) {
            node(id: $projectId) {
                ... on ProjectV2 {
                    fields(first: 100) {
                        nodes {
                            ... on ProjectV2Field {
                                id
                                name
                                dataType
                            }
                        }
                    }
                }
            }
        }' \
        -f projectId="$project_id" \
        --jq ".data.node.fields.nodes[] | select(.name == \"${field_name}\") | .id" 2>/dev/null | head -n1)

    local data_type
    data_type=$(gh api graphql \
        -f query='
        query($projectId: ID!) {
            node(id: $projectId) {
                ... on ProjectV2 {
                    fields(first: 100) {
                        nodes {
                            ... on ProjectV2Field {
                                id
                                name
                                dataType
                            }
                        }
                    }
                }
            }
        }' \
        -f projectId="$project_id" \
        --jq ".data.node.fields.nodes[] | select(.name == \"${field_name}\") | .dataType" 2>/dev/null | head -n1)

    if [[ -n "$field_id" ]]; then
        case "$data_type" in
            DATE)
                local iso_date
                iso_date=$(normalize_date_to_iso "$raw_value" 2>/dev/null || true)
                [[ -z "$iso_date" ]] && return 1
                gh api graphql \
                    -f query='
                    mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $date: Date!) {
                        updateProjectV2ItemFieldValue(
                            input: {
                                projectId: $projectId
                                itemId: $itemId
                                fieldId: $fieldId
                                value: { date: $date }
                            }
                        ) {
                            projectV2Item { id }
                        }
                    }' \
                    -f projectId="$project_id" \
                    -f itemId="$item_id" \
                    -f fieldId="$field_id" \
                    -f date="$iso_date" \
                    --jq '.data.updateProjectV2ItemFieldValue.projectV2Item.id' >/dev/null 2>&1
                return $?
                ;;
            NUMBER)
                if [[ ! "$raw_value" =~ ^-?[0-9]+([.][0-9]+)?$ ]]; then
                    return 1
                fi
                gh api graphql \
                    -f query='
                    mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $number: Float!) {
                        updateProjectV2ItemFieldValue(
                            input: {
                                projectId: $projectId
                                itemId: $itemId
                                fieldId: $fieldId
                                value: { number: $number }
                            }
                        ) {
                            projectV2Item { id }
                        }
                    }' \
                    -f projectId="$project_id" \
                    -f itemId="$item_id" \
                    -f fieldId="$field_id" \
                    -F number="$raw_value" \
                    --jq '.data.updateProjectV2ItemFieldValue.projectV2Item.id' >/dev/null 2>&1
                return $?
                ;;
            TEXT)
                gh api graphql \
                    -f query='
                    mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $text: String!) {
                        updateProjectV2ItemFieldValue(
                            input: {
                                projectId: $projectId
                                itemId: $itemId
                                fieldId: $fieldId
                                value: { text: $text }
                            }
                        ) {
                            projectV2Item { id }
                        }
                    }' \
                    -f projectId="$project_id" \
                    -f itemId="$item_id" \
                    -f fieldId="$field_id" \
                    -f text="$raw_value" \
                    --jq '.data.updateProjectV2ItemFieldValue.projectV2Item.id' >/dev/null 2>&1
                return $?
                ;;
            *)
                # Unsupported system-like field data types (TITLE, ASSIGNEES, etc.)
                return 1
                ;;
        esac
    fi

    # 3) Iteration field path (value should match iteration title)
    local iteration_field_id
    iteration_field_id=$(gh api graphql \
        -f query='
        query($projectId: ID!) {
            node(id: $projectId) {
                ... on ProjectV2 {
                    fields(first: 100) {
                        nodes {
                            ... on ProjectV2IterationField {
                                id
                                name
                            }
                        }
                    }
                }
            }
        }' \
        -f projectId="$project_id" \
        --jq ".data.node.fields.nodes[] | select(.name == \"${field_name}\") | .id" 2>/dev/null | head -n1)

    if [[ -n "$iteration_field_id" ]]; then
        local iteration_id
        iteration_id=$(gh api graphql \
            -f query='
            query($projectId: ID!) {
                node(id: $projectId) {
                    ... on ProjectV2 {
                        fields(first: 100) {
                            nodes {
                                ... on ProjectV2IterationField {
                                    name
                                    configuration {
                                        iterations {
                                            id
                                            title
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }' \
            -f projectId="$project_id" \
            --jq ".data.node.fields.nodes[] | select(.name == \"${field_name}\") | .configuration.iterations[] | select(.title == \"${raw_value}\") | .id" 2>/dev/null | head -n1)

        [[ -z "$iteration_id" ]] && return 1

        gh api graphql \
            -f query='
            mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $iterationId: String!) {
                updateProjectV2ItemFieldValue(
                    input: {
                        projectId: $projectId
                        itemId: $itemId
                        fieldId: $fieldId
                        value: { iterationId: $iterationId }
                    }
                ) {
                    projectV2Item { id }
                }
            }' \
            -f projectId="$project_id" \
            -f itemId="$item_id" \
            -f fieldId="$iteration_field_id" \
            -f iterationId="$iteration_id" \
            --jq '.data.updateProjectV2ItemFieldValue.projectV2Item.id' >/dev/null 2>&1
        return $?
    fi

    return 1
}

apply_custom_project_fields() {
    local project_id="$1"
    local item_id="$2"
    local repo="$3"
    local child_issue_number="$4"
    local had_error=0

    for kv in "${PROJECT_FIELDS[@]}"; do
        local field_name="${kv%%=*}"
        local field_value="${kv#*=}"

        # Require "Name=Value"
        if [[ -z "$field_name" || "$field_name" == "$kv" ]]; then
            echo -e "${RED}Error: Invalid --field value '$kv' (expected Name=Value)${NC}"
            had_error=1
            continue
        fi

        field_name="$(echo "$field_name" | sed -E 's/^[[:space:]]+|[[:space:]]+$//g')"
        field_value="$(echo "$field_value" | sed -E 's/^[[:space:]]+|[[:space:]]+$//g')"

        # Special case: Parent issue is a repo hierarchy relation, not a normal project field write.
        if [[ "$field_name" == "Parent issue" ]]; then
            if ! set_parent_issue_relationship "$repo" "$child_issue_number" "$field_value"; then
                echo -e "${RED}Error: Failed to set parent issue from '${field_value}'${NC}"
                had_error=1
            fi
            continue
        fi

        if ! set_project_v2_field_value "$project_id" "$item_id" "$field_name" "$field_value"; then
            echo -e "${RED}Error: Failed to set project field '${field_name}'='${field_value}'${NC}"
            had_error=1
        fi
    done

    [[ "$had_error" -eq 0 ]]
}

# Find existing Project v2 item id for an issue number (fallback when add mutation does not return item id)
find_project_v2_item_id_by_issue_number() {
    local project_id="$1"
    local issue_number="$2"
    gh api graphql \
        -f query='
        query($projectId: ID!) {
            node(id: $projectId) {
                ... on ProjectV2 {
                    items(first: 100) {
                        nodes {
                            id
                            content {
                                ... on Issue {
                                    number
                                }
                            }
                        }
                    }
                }
            }
        }' \
        -f projectId="$project_id" \
        --jq ".data.node.items.nodes[] | select(.content.number == ${issue_number}) | .id" 2>/dev/null | head -n1
}

# Add issue to project (supports both classic projects and project v2)
add_issue_to_project() {
    local issue_id="$1"
    local project_id="$2"
    local repo="$3"
    local issue_number="$4"
    local project_type_value="$5"
    local is_valid_item_id_regex='^PVTI_'
    
    # Check if it's a project v2 (ID starts with PVT_ or PVTI_)
    if [[ "$project_id" =~ ^PVT_ ]] || [[ "$project_id" =~ ^PVTI_ ]]; then
        # Project v2 - use GraphQL mutation
        local item_id
        item_id=$(gh api graphql \
            -f query='
            mutation($projectId: ID!, $contentId: ID!) {
                addProjectV2ItemById(input: {projectId: $projectId, contentId: $contentId}) {
                    item {
                        id
                    }
                }
            }' \
            -f projectId="$project_id" \
            -f contentId="$issue_id" \
            --jq '.data.addProjectV2ItemById.item.id' 2>/dev/null || echo "")

        # Guard against GraphQL error JSON being captured as a non-empty string.
        if [[ ! "$item_id" =~ $is_valid_item_id_regex ]]; then
            item_id=""
        fi
        
        if [[ -z "$item_id" ]]; then
            item_id=$(find_project_v2_item_id_by_issue_number "$project_id" "$issue_number")
            if [[ ! "$item_id" =~ $is_valid_item_id_regex ]]; then
                item_id=""
            fi
        fi

        if [[ -n "$item_id" ]]; then
            if ! set_project_v2_type_field "$project_id" "$item_id" "$project_type_value"; then
                # Retry once after resolving current item id from project list.
                local retry_item_id
                retry_item_id=$(find_project_v2_item_id_by_issue_number "$project_id" "$issue_number")
                if [[ "$retry_item_id" =~ $is_valid_item_id_regex ]]; then
                    item_id="$retry_item_id"
                fi
                if ! set_project_v2_type_field "$project_id" "$item_id" "$project_type_value"; then
                    echo -e "${RED}Error: Added to project, but failed to set Type field${NC}"
                    return 1
                fi
            fi

            # Apply additional custom project fields if provided.
            if [[ ${#PROJECT_FIELDS[@]} -gt 0 ]]; then
                if ! apply_custom_project_fields "$project_id" "$item_id" "$repo" "$issue_number"; then
                    echo -e "${RED}Error: Added to project, but failed to set one or more requested fields${NC}"
                    return 1
                fi
            fi
            return 0
        fi
    else
        # Classic project - use REST API
        # Get the first column of the project
        local column_id
        column_id=$(gh api "projects/${project_id}/columns" --jq '.[0].id' 2>/dev/null || echo "")
        
        if [[ -n "$column_id" ]]; then
            # For classic projects, we need to use the issue number, not node ID
            # Get the issue ID from the repository
            local repo_owner="${repo%%/*}"
            local repo_name="${repo#*/}"
            local issue_api_id
            
            # Try to get the issue content ID (this is different from node ID)
            issue_api_id=$(gh api "repos/${repo}/issues/${issue_number}" --jq '.id' 2>/dev/null || echo "")
            
            if [[ -n "$issue_api_id" ]]; then
                # Add card to the first column using the issue API ID
                gh api "projects/columns/${column_id}/cards" \
                    -f content_id="$issue_api_id" \
                    -f content_type="Issue" \
                    >/dev/null 2>&1 && return 0
            fi
        fi
    fi
    
    return 1
}

# Main function
main() {
    parse_args "$@"
    
    # Check if gh CLI is installed and authenticated
    if ! command -v gh &> /dev/null; then
        echo -e "${RED}Error: GitHub CLI (gh) is not installed${NC}"
        echo "Install it from: https://cli.github.com/"
        exit 1
    fi
    
    if ! gh auth status &> /dev/null; then
        echo -e "${RED}Error: GitHub CLI is not authenticated${NC}"
        echo "Run: gh auth login"
        exit 1
    fi
    
    # Resolve repository
    local repo
    if ! repo=$(resolve_repo); then
        echo -e "${RED}Error: Could not determine repository${NC}"
        echo "Set github.github_repo in infra/infra.yaml, run from a repo with origin pointing at GitHub, or use --repo"
        exit 1
    fi
    
    echo -e "${GREEN}Creating issue in repository: ${repo}${NC}"
    
    # Get template path
    local template_path
    template_path=$(get_template_path "$ISSUE_TYPE")
    
    if [[ ! -f "$template_path" ]]; then
        echo -e "${YELLOW}Warning: Template file not found: $template_path${NC}"
        echo "Creating issue without template..."
    fi
    
    # Build title with prefix
    local title_prefix
    # Title prefix: when --type is Epic or Initiative, use [EPIC] or [INITIATIVE] (Type in all caps).
    # Otherwise use the template prefix ([FEATURE], [BUG], [TASK]).
    local type_override_normalized
    type_override_normalized=$(map_issue_type_to_project_type "$PROJECT_TYPE_OVERRIDE")
    if [[ "$type_override_normalized" == "Epic" ]] || [[ "$type_override_normalized" == "Initiative" ]]; then
        title_prefix=$(echo "$type_override_normalized" | tr '[:lower:]' '[:upper:]')
    else
        title_prefix=$(get_title_prefix "$template_path")
    fi
    local full_title="$TITLE"
    # If the caller already provided a [TYPE] prefix, preserve it as-is.
    # Otherwise apply the chosen prefix (EPIC, INITIATIVE, FEATURE, BUG, TASK).
    if [[ -n "$title_prefix" ]] && [[ ! "$TITLE" =~ ^\[[^]]+\] ]]; then
        local title_prefix_upper
        title_prefix_upper=$(echo "$title_prefix" | tr '[:lower:]' '[:upper:]')
        full_title="[$title_prefix_upper] $TITLE"
    fi
    
    # Get default label
    local default_label
    default_label=$(get_default_label "$template_path")
    
    # Template labels are treated as Type metadata for project fields, not repo labels.
    # Only user-provided --label values are added as repository labels.
    local all_labels="$LABELS"

    # Determine project Type value from title prefix > template label > issue category.
    local project_type_value
    project_type_value=$(infer_project_type_value "$PROJECT_TYPE_OVERRIDE" "$ISSUE_TYPE" "$full_title" "$default_label")
    
    # Build issue body
    local issue_body
    issue_body=$(build_issue_body "$template_path" "$BODY")
    
    # Build gh issue create command
    local create_cmd="gh issue create"
    create_cmd="$create_cmd --repo \"$repo\""
    create_cmd="$create_cmd --title \"$full_title\""
    
    if [[ -n "$issue_body" ]]; then
        # Use a temporary file for the body to handle multiline content
        local body_file
        body_file=$(mktemp)
        echo -e "$issue_body" > "$body_file"
        create_cmd="$create_cmd --body-file \"$body_file\""
    fi
    
    # Don't add labels during creation (they may not exist in repo)
    # We'll add them separately after creation if they exist
    
    if [[ -n "$ASSIGNEE" ]]; then
        create_cmd="$create_cmd --assignee \"$ASSIGNEE\""
    fi
    
    # Create the issue (without labels first)
    echo -e "${GREEN}Creating issue...${NC}"
    local issue_url
    issue_url=$(eval "$create_cmd" 2>&1)
    local create_exit_code=$?
    
    # Clean up temp file if created
    [[ -n "${body_file:-}" ]] && rm -f "$body_file"
    
    if [[ $create_exit_code -ne 0 ]]; then
        echo -e "${RED}Error: Failed to create issue${NC}"
        echo "$issue_url"
        exit 1
    fi
    
    echo -e "${GREEN}Issue created: $issue_url${NC}"
    
    # Try to add labels if provided (but don't fail if label doesn't exist)
    if [[ -n "$all_labels" ]]; then
        # Extract issue number from URL
        local issue_num
        issue_num=$(echo "$issue_url" | grep -oE '[0-9]+$' || echo "")
        if [[ -n "$issue_num" ]]; then
            echo -e "${GREEN}Adding labels...${NC}"
            # Try to add labels, but continue even if it fails (label might not exist)
            gh issue edit "$issue_num" --repo "$repo" --add-label "$all_labels" 2>/dev/null || echo -e "${YELLOW}Warning: Could not add label(s): $all_labels (label may not exist in repository)${NC}"
        fi
    fi
    
    # Extract issue number from URL
    local issue_number
    issue_number=$(echo "$issue_url" | grep -oE '[0-9]+$' || echo "")
    
    if [[ -z "$issue_number" ]]; then
        echo -e "${YELLOW}Warning: Could not extract issue number from URL${NC}"
        echo "Please manually add the issue to the project: $PROJECT_NAME"
        exit 0
    fi
    
    # Find project ID
    echo -e "${GREEN}Finding project: $PROJECT_NAME${NC}"
    local project_id
    if ! project_id=$(find_project_id "$repo" "$PROJECT_NAME"); then
        echo -e "${YELLOW}Warning: Could not find project '$PROJECT_NAME'${NC}"
        echo "Issue created but not added to project. Please add it manually."
        exit 0
    fi
    
    # Get the issue node ID (required for GraphQL API)
    local issue_node_id
    issue_node_id=$(gh api graphql \
        -f query='
        query($owner: String!, $repo: String!, $number: Int!) {
            repository(owner: $owner, name: $repo) {
                issue(number: $number) {
                    id
                }
            }
        }' \
        -f owner="${repo%%/*}" \
        -f repo="${repo#*/}" \
        -F number="$issue_number" \
        --jq '.data.repository.issue.id' 2>/dev/null || echo "")
    
    if [[ -z "$issue_node_id" ]] || [[ ! "$issue_node_id" =~ ^I_ ]]; then
        echo -e "${YELLOW}Warning: Could not get issue node ID${NC}"
        echo "Issue created but not added to project. Please add it manually."
        exit 0
    fi
    
    # Add issue to project
    echo -e "${GREEN}Adding issue to project: $PROJECT_NAME${NC}"
    if add_issue_to_project "$issue_node_id" "$project_id" "$repo" "$issue_number" "$project_type_value"; then
        echo -e "${GREEN}✓ Issue successfully added to project!${NC}"
    else
        echo -e "${YELLOW}Warning: Failed to add issue to project${NC}"
        echo "Issue created: $issue_url"
        echo "Please add it manually to the project: $PROJECT_NAME"
        echo ""
        echo "Note: Make sure you have the 'project' scope enabled:"
        echo "  gh auth refresh -s project"
        exit 0
    fi
    
    echo ""
    echo -e "${GREEN}✓ Issue created and added to project successfully!${NC}"
    echo "  URL: $issue_url"
    echo "  Project: $PROJECT_NAME"
}

# Run main function with all arguments
main "$@"
